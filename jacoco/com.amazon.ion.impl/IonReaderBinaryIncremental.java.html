<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonReaderBinaryIncremental.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">IonReaderBinaryIncremental.java</span></div><h1>IonReaderBinaryIncremental.java</h1><pre class="source lang-java linenums">package com.amazon.ion.impl;

import com.amazon.ion.Decimal;
import com.amazon.ion.IntegerSize;
import com.amazon.ion.IonBufferConfiguration;
import com.amazon.ion.IonCatalog;
import com.amazon.ion.IonException;
import com.amazon.ion.IonReader;
import com.amazon.ion.IonStruct;
import com.amazon.ion.IonType;
import com.amazon.ion.IonWriter;
import com.amazon.ion.ReadOnlyValueException;
import com.amazon.ion.SymbolTable;
import com.amazon.ion.SymbolToken;
import com.amazon.ion.Timestamp;
import com.amazon.ion.UnknownSymbolException;
import com.amazon.ion.ValueFactory;
import com.amazon.ion.impl.bin.IntList;
import com.amazon.ion.system.IonReaderBuilder;
import com.amazon.ion.impl.bin.utf8.Utf8StringDecoder;
import com.amazon.ion.impl.bin.utf8.Utf8StringDecoderPool;
import com.amazon.ion.system.SimpleCatalog;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * &lt;p&gt;
 * This implementation differs from the existing non-incremental binary reader implementation in that if
 * {@link IonReader#next()} returns {@code null} at the top-level, it indicates that there is not (yet) enough data in
 * the stream to complete a top-level value. The user may wait for more data to become available in the stream and
 * call {@link IonReader#next()} again to continue reading. Unlike the non-incremental reader, the incremental reader
 * will never throw an exception due to unexpected EOF during {@code next()}. If, however, {@link IonReader#close()} is
 * called when an incomplete value is buffered, an {@link IonException} will be raised.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Although the incremental binary reader implementation provides performance superior to the non-incremental reader
 * implementation for both incremental and non-incremental use cases, there is one caveat: the incremental
 * implementation must be able to buffer an entire top-level value and any preceding system values (Ion version
 * marker(s) and symbol table(s)) in memory. This means that each value and preceding system values must be no larger
 * than any of the following:
 * &lt;ul&gt;
 * &lt;li&gt;The configured maximum buffer size of the {@link IonBufferConfiguration}.&lt;/li&gt;
 * &lt;li&gt;The memory available to the JVM.&lt;/li&gt;
 * &lt;li&gt;2GB, because the buffer is held in a Java {@code byte[]}, which is indexed by an {@code int}.&lt;/li&gt;
 * &lt;/ul&gt;
 * This will not be a problem for the vast majority of Ion streams, as it is
 * rare for a single top-level value or symbol table to exceed a few megabytes in size. However, if the size of the
 * stream's values risk exceeding the available memory, then this implementation must not be used.
 * &lt;/p&gt;
 * &lt;p&gt;
 * To enable this implementation, use {@code IonReaderBuilder.withIncrementalReadingEnabled(true)}.
 * &lt;/p&gt;
 */
class IonReaderBinaryIncremental implements IonReader, _Private_ReaderWriter, _Private_IncrementalReader {

    /*
     * Potential future enhancements:
     * - Split this implementation into a user-level reader and a system-level reader, like the existing implementation.
     *   This allows this implementation to be used when the user requests a system reader.
     * - Do not require buffering an entire top-level value. This would be a pretty major overhaul. It may be possible
     *   to implement using different buffers for each depth. Doing this may also make it possible to avoid buffering
     *   a value (at any depth) until stepIn() or *Value() is called on it, enabling faster skip-scanning.
     * - Allow for this implementation to produce the same non-incremental behavior as the old implementation; namely,
     *   that running out of data during next() would raise an IonException. See the note in the implementation of
     *   close() below. Implementing this bullet and the previous two bullets would allow us to remove the old binary
     *   IonReader implementation.
     * - Add a builder/constructor option that uses a user-provided byte[] directly. This would allow data to be read
     *   in-place without the need to copy to a separate buffer. Non-incremental behavior (as described in the previous
     *   bullet) is likely a requirement of this feature.
     * - System symbol table configuration needs to be generalized to support future Ion versions. See the constructor,
     *   resetSymbolTable(), and resetImports().
     * - When accessed via an iterator, annotations can be parsed incrementally instead of parsing the entire sequence
     *   up-front.
     * - Provide users the option to spawn a thread that pre-buffers the next value. There would be two buffers: one
     *   for the user thread, and one for the pre-fetching thread. They are swapped every time the user calls next().
     */

    /**
     * Holds the information that the binary reader must keep track of for containers at any depth.
     */
    private static class ContainerInfo {

        /**
         * The container's type.
         */
        private IonType type;

        /**
         * The byte position of the end of the container.
         */
        private int endPosition;
    }

    /**
     * The standard {@link IonBufferConfiguration}. This will be used unless the user chooses custom settings.
     */
    private static final IonBufferConfiguration STANDARD_BUFFER_CONFIGURATION =
<span class="fc" id="L110">        IonBufferConfiguration.Builder.standard().build();</span>

    // Constructs ContainerInfo instances.
<span class="fc" id="L113">    private static final _Private_RecyclingStack.ElementFactory&lt;ContainerInfo&gt; CONTAINER_INFO_FACTORY =</span>
<span class="fc" id="L114">        new _Private_RecyclingStack.ElementFactory&lt;ContainerInfo&gt;() {</span>

        @Override
        public ContainerInfo newElement() {
<span class="fc" id="L118">            return new ContainerInfo();</span>
        }
    };

    // Symbol IDs for symbols contained in the system symbol table.
    private static class SystemSymbolIDs {

        // The system symbol table SID for the text &quot;$ion_symbol_table&quot;.
        private static final int ION_SYMBOL_TABLE_ID = 3;

        // The system symbol table SID for the text &quot;name&quot;.
        private static final int NAME_ID = 4;

        // The system symbol table SID for the text &quot;version&quot;.
        private static final int VERSION_ID = 5;

        // The system symbol table SID for the text &quot;imports&quot;.
        private static final int IMPORTS_ID = 6;

        // The system symbol table SID for the text &quot;symbols&quot;.
        private static final int SYMBOLS_ID = 7;

        // The system symbol table SID for the text &quot;max_id&quot;.
        private static final int MAX_ID_ID = 8;
    }

    /**
     * @param value a non-negative number.
     * @return the exponent of the next power of two greater than the given number.
     */
    private static int logBase2(int value) {
<span class="fc bfc" id="L149" title="All 2 branches covered.">        return 32 - Integer.numberOfLeadingZeros(value == 0 ? 0 : value - 1);</span>
    }

    /**
     * Cache of configurations for fixed-sized streams. FIXED_SIZE_CONFIGURATIONS[i] returns a configuration with
     * buffer size max(8, 2^i). Retrieve a configuration large enough for a given size using
     * FIXED_SIZE_CONFIGURATIONS(logBase2(size)). Only supports sizes less than or equal to
     * STANDARD_BUFFER_CONFIGURATION.getInitialBufferSize().
     */
    private static final IonBufferConfiguration[] FIXED_SIZE_CONFIGURATIONS;

    static {
<span class="fc" id="L161">        int maxBufferSizeExponent = logBase2(STANDARD_BUFFER_CONFIGURATION.getInitialBufferSize());</span>
<span class="fc" id="L162">        FIXED_SIZE_CONFIGURATIONS = new IonBufferConfiguration[maxBufferSizeExponent + 1];</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">        for (int i = 0; i &lt;= maxBufferSizeExponent; i++) {</span>
            // Create a buffer configuration for buffers of size 2^i. The minimum size is 8: the smallest power of two
            // larger than the minimum buffer size allowed.
<span class="fc" id="L166">            int size = Math.max(8, (int) Math.pow(2, i));</span>
<span class="fc" id="L167">            FIXED_SIZE_CONFIGURATIONS[i] = IonBufferConfiguration.Builder.from(STANDARD_BUFFER_CONFIGURATION)</span>
<span class="fc" id="L168">                .withInitialBufferSize(size)</span>
<span class="fc" id="L169">                .withMaximumBufferSize(size)</span>
<span class="fc" id="L170">                .build();</span>
        }
    }

    // The final byte of the binary IVM.
    private static final int IVM_FINAL_BYTE = 0xEA;

    // Isolates the highest bit in a byte.
    private static final int HIGHEST_BIT_BITMASK = 0x80;

    // Isolates the lowest seven bits in a byte.
    private static final int LOWER_SEVEN_BITS_BITMASK = 0x7F;

    // Isolates the lowest six bits in a byte.
    private static final int LOWER_SIX_BITS_BITMASK = 0x3F;

    // The number of significant bits in each UInt byte.
    private static final int VALUE_BITS_PER_UINT_BYTE = 8;

    // The number of significant bits in each VarUInt byte.
    private static final int VALUE_BITS_PER_VARUINT_BYTE = 7;

    // An IonCatalog containing zero shared symbol tables.
<span class="fc" id="L193">    private static final IonCatalog EMPTY_CATALOG = new SimpleCatalog();</span>

    // Initial capacity of the stack used to hold ContainerInfo. Each additional level of nesting in the data requires
    // a new ContainerInfo. Depths greater than 8 will be rare.
    private static final int CONTAINER_STACK_INITIAL_CAPACITY = 8;

    // Initial capacity of the ArrayList used to hold the symbol IDs of the annotations on the current value.
    private static final int ANNOTATIONS_LIST_INITIAL_CAPACITY = 8;

    // Initial capacity of the ArrayList used to hold the text in the current symbol table.
    private static final int SYMBOLS_LIST_INITIAL_CAPACITY = 128;

    // Single byte negative zero, represented as a VarInt. Often used in timestamp encodings to indicate unknown local
    // offset.
    private static final int VAR_INT_NEGATIVE_ZERO = 0xC0;

    // The number of bytes occupied by a Java int.
    private static final int INT_SIZE_IN_BYTES = 4;

    // The number of bytes occupied by a Java long.
    private static final int LONG_SIZE_IN_BYTES = 8;

    // The smallest negative 8-byte integer that can fit in a long is -0x80_00_00_00_00_00_00_00.
    private static final int MOST_SIGNIFICANT_BYTE_OF_MIN_LONG = 0x80;

    // The largest positive 8-byte integer that can fit in a long is 0x7F_FF_FF_FF_FF_FF_FF_FF.
    private static final int MOST_SIGNIFICANT_BYTE_OF_MAX_LONG = 0x7F;

    // The second-most significant bit in the most significant byte of a VarInt is the sign.
    private static final int VAR_INT_SIGN_BITMASK = 0x40;

    // 32-bit floats must declare length 4.
    private static final int FLOAT_32_BYTE_LENGTH = 4;

    // The imports for Ion 1.0 data with no shared user imports.
<span class="fc" id="L228">    private static final LocalSymbolTableImports ION_1_0_IMPORTS</span>
<span class="fc" id="L229">        = new LocalSymbolTableImports(SharedSymbolTable.getSystemSymbolTable(1));</span>

    // The InputStream that provides the binary Ion data.
    private final InputStream inputStream;

    // Wrapper for the InputStream that ensures an entire top-level value is available.
    private final IonReaderLookaheadBuffer lookahead;

    // Buffer that stores top-level values.
    private final ResizingPipedInputStream buffer;

    // Converter between scalar types, allowing, for example, for a value encoded as an Ion float to be returned as a
    // Java `long` via `IonReader.longValue()`.
    private final _Private_ScalarConversions.ValueVariant scalarConverter;

    // Stack to hold container info. Stepping into a container results in a push; stepping out results in a pop.
    private final _Private_RecyclingStack&lt;ContainerInfo&gt; containerStack;

<span class="fc" id="L247">    private final Utf8StringDecoder utf8Decoder = Utf8StringDecoderPool.getInstance().getOrCreate();</span>

    // The symbol IDs for the annotations on the current value.
    private final IntList annotationSids;

    // True if the annotation iterator will be reused across values; otherwise, false.
    private final boolean isAnnotationIteratorReuseEnabled;

    // Reusable iterator over the annotations on the current value.
    private final AnnotationIterator annotationIterator;

    // The text representations of the symbol table that is currently in scope, indexed by symbol ID. If the element at
    // a particular index is null, that symbol has unknown text.
    private final List&lt;String&gt; symbols;

    // The catalog used by the reader to resolve shared symbol table imports.
    private final IonCatalog catalog;

    // The shared symbol tables imported by the local symbol table that is currently in scope.
<span class="fc" id="L266">    private LocalSymbolTableImports imports = ION_1_0_IMPORTS;</span>

    // A map of symbol ID to SymbolToken representation. Because most use cases only require symbol text, this
    // is used only if necessary to avoid imposing the extra expense on all symbol lookups.
<span class="fc" id="L270">    private List&lt;SymbolToken&gt; symbolTokensById = null;</span>

    // The cached SymbolTable representation of the current local symbol table. Invalidated whenever a local
    // symbol table is encountered in the stream.
<span class="fc" id="L274">    private SymbolTable cachedReadOnlySymbolTable = null;</span>

    // The SymbolTable that was transferred via the last call to pop_passed_symbol_table.
<span class="fc" id="L277">    private SymbolTable symbolTableLastTransferred = null;</span>

    // The symbol ID of the current value's field name, or -1 if the current value is not in a struct.
<span class="fc" id="L280">    private int fieldNameSid = -1;</span>

    // The major version of the Ion encoding currently being read.
<span class="fc" id="L283">    private int majorVersion = 1;</span>

    // The minor version of the Ion encoding currently being read.
<span class="fc" id="L286">    private int minorVersion = 0;</span>

    // The number of bytes of a lob value that the user has consumed, allowing for piecewise reads.
<span class="fc" id="L289">    private int lobBytesRead = 0;</span>

    // The type of value at which the reader is currently positioned.
<span class="fc" id="L292">    private IonType valueType = null;</span>

    // Information about the type ID byte for the value at which the reader is currently positioned.
<span class="fc" id="L295">    private IonTypeID valueTypeID = null;</span>

    // Indicates whether there are annotations on the current value.
<span class="fc" id="L298">    private boolean hasAnnotations = false;</span>

    // Indicates whether a complete top-level value is currenty buffered.
<span class="fc" id="L301">    private boolean completeValueBuffered = false;</span>

    // --- Byte position markers ---
    // Note: absolute positions/indexes can be used because the bytes that represent a single top-level value are
    // always handled in two sequential phases: first, the bytes are buffered, and then they are read. These operations
    // will never be interleaved during the processing of a single value. As a result, the underlying buffer
    // will always hold all of the bytes for a single top-level value in a contiguous sequence, even if the buffer
    // has to grow to hold all of the value's bytes.

    // The buffer position of the first byte of the value representation (after the type ID and optional length field).
<span class="fc" id="L311">    private int valueStartPosition = -1;</span>

    // The buffer position of the byte after the last byte in the value representation.
<span class="fc" id="L314">    private int valueEndPosition = -1;</span>

    // The buffer position of the first byte of the annotation wrapper for the current value.
<span class="fc" id="L317">    private int annotationStartPosition = -1;</span>

    // The buffer position of the byte after the last byte in the annotation wrapper for the current value.
<span class="fc" id="L320">    private int annotationEndPosition = -1;</span>

    // The index of the next byte to peek from the underlying buffer.
<span class="fc" id="L323">    private int peekIndex = -1;</span>

    // ------

    /**
     * Constructor.
     * @param builder the builder containing the configuration for the new reader.
     * @param inputStream the InputStream that provides binary Ion data.
     */
<span class="fc" id="L332">    IonReaderBinaryIncremental(IonReaderBuilder builder, InputStream inputStream) {</span>
<span class="fc" id="L333">        this.inputStream = inputStream;</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">        this.catalog = builder.getCatalog() == null ? EMPTY_CATALOG : builder.getCatalog();</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (builder.isAnnotationIteratorReuseEnabled()) {</span>
<span class="fc" id="L336">            isAnnotationIteratorReuseEnabled = true;</span>
<span class="fc" id="L337">            annotationIterator = new AnnotationIterator();</span>
        } else {
<span class="fc" id="L339">            isAnnotationIteratorReuseEnabled = false;</span>
<span class="fc" id="L340">            annotationIterator = null;</span>
        }
<span class="fc" id="L342">        IonBufferConfiguration configuration = builder.getBufferConfiguration();</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (configuration == null) {</span>
<span class="fc" id="L344">            configuration = STANDARD_BUFFER_CONFIGURATION;</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">            if (inputStream instanceof ByteArrayInputStream) {</span>
                // ByteArrayInputStreams are fixed-size streams. Clamp the reader's internal buffer size at the size of
                // the stream to avoid wastefully allocating extra space that will never be needed. It is still
                // preferable for the user to manually specify the buffer size if it's less than the default, as doing
                // so allows this branch to be skipped.
                int fixedBufferSize;
                try {
<span class="fc" id="L352">                    fixedBufferSize = inputStream.available();</span>
<span class="nc" id="L353">                } catch (IOException e) {</span>
                    // ByteArrayInputStream.available() does not throw.
<span class="nc" id="L355">                    throw new IllegalStateException(e);</span>
<span class="fc" id="L356">                }</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">                if (configuration.getInitialBufferSize() &gt; fixedBufferSize) {</span>
<span class="fc" id="L358">                    configuration = FIXED_SIZE_CONFIGURATIONS[logBase2(fixedBufferSize)];</span>
                }
            }
        }
<span class="fc" id="L362">        lookahead = new IonReaderLookaheadBuffer(configuration, inputStream);</span>
<span class="fc" id="L363">        buffer = (ResizingPipedInputStream) lookahead.getPipe();</span>
<span class="fc" id="L364">        containerStack = new _Private_RecyclingStack&lt;ContainerInfo&gt;(</span>
            CONTAINER_STACK_INITIAL_CAPACITY,
            CONTAINER_INFO_FACTORY
        );
<span class="fc" id="L368">        annotationSids = new IntList(ANNOTATIONS_LIST_INITIAL_CAPACITY);</span>
<span class="fc" id="L369">        symbols = new ArrayList&lt;String&gt;(SYMBOLS_LIST_INITIAL_CAPACITY);</span>
<span class="fc" id="L370">        scalarConverter = new _Private_ScalarConversions.ValueVariant();</span>
<span class="fc" id="L371">        resetImports();</span>
<span class="fc" id="L372">    }</span>

    /**
     * Reusable iterator over the annotations on the current value.
     */
<span class="fc" id="L377">    private class AnnotationIterator implements Iterator&lt;String&gt; {</span>

        // The byte position of the annotation to return from the next call to next().
        private int nextAnnotationPeekIndex;

        @Override
        public boolean hasNext() {
<span class="fc bfc" id="L384" title="All 2 branches covered.">            return nextAnnotationPeekIndex &lt; annotationEndPosition;</span>
        }

        @Override
        public String next() {
<span class="fc" id="L389">            int savedPeekIndex = peekIndex;</span>
<span class="fc" id="L390">            peekIndex = nextAnnotationPeekIndex;</span>
<span class="fc" id="L391">            int sid = readVarUInt();</span>
<span class="fc" id="L392">            nextAnnotationPeekIndex = peekIndex;</span>
<span class="fc" id="L393">            peekIndex = savedPeekIndex;</span>
<span class="fc" id="L394">            String annotation = getSymbol(sid);</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            if (annotation == null) {</span>
<span class="fc" id="L396">                throw new UnknownSymbolException(sid);</span>
            }
<span class="fc" id="L398">            return annotation;</span>
        }

        @Override
        public void remove() {
<span class="nc" id="L403">            throw new UnsupportedOperationException(&quot;This iterator does not support element removal.&quot;);</span>
        }

        /**
         * Prepare the iterator to iterate over the annotations on the current value.
         */
        void ready() {
<span class="fc" id="L410">            nextAnnotationPeekIndex = annotationStartPosition;</span>
<span class="fc" id="L411">        }</span>

        /**
         * Invalidate the iterator so that all future calls to {@link #hasNext()} will return false until the
         * next call to {@link #ready()}.
         */
        void invalidate() {
<span class="fc" id="L418">            nextAnnotationPeekIndex = Integer.MAX_VALUE;</span>
<span class="fc" id="L419">        }</span>
    }

    /**
     * Non-reusable iterator over the annotations on the current value. May be iterated even if the reader advances
     * past the current value.
     */
    private class SingleUseAnnotationIterator implements Iterator&lt;String&gt; {

        // All of the annotation SIDs on the current value.
        private final IntList annotationSids;
        // The index into `annotationSids` containing the next annotation to be returned.
<span class="fc" id="L431">        private int index = 0;</span>

<span class="fc" id="L433">        SingleUseAnnotationIterator() {</span>
<span class="fc" id="L434">            annotationSids = new IntList(getAnnotationSids());</span>
<span class="fc" id="L435">        }</span>

        @Override
        public boolean hasNext() {
<span class="fc bfc" id="L439" title="All 2 branches covered.">            return index &lt; annotationSids.size();</span>
        }

        @Override
        public String next() {
<span class="fc" id="L444">            int sid = annotationSids.get(index);</span>
<span class="fc" id="L445">            String annotation = getSymbol(sid);</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">            if (annotation == null) {</span>
<span class="nc" id="L447">                throw new UnknownSymbolException(sid);</span>
            }
<span class="fc" id="L449">            index++;</span>
<span class="fc" id="L450">            return annotation;</span>
        }

        @Override
        public void remove() {
<span class="nc" id="L455">            throw new UnsupportedOperationException(&quot;This iterator does not support element removal.&quot;);</span>
        }
    }

    /**
     * SymbolToken implementation that includes ImportLocation.
     */
    static class SymbolTokenImpl implements _Private_SymbolToken {

        // The symbol's text, or null if the text is unknown.
        private final String text;

        // The local symbol ID of this symbol within a particular local symbol table.
        private final int sid;

        // The import location of the symbol (only relevant if the text is unknown).
        private final ImportLocation importLocation;

<span class="fc" id="L473">        SymbolTokenImpl(String text, int sid, ImportLocation importLocation) {</span>
<span class="fc" id="L474">            this.text = text;</span>
<span class="fc" id="L475">            this.sid = sid;</span>
<span class="fc" id="L476">            this.importLocation = importLocation;</span>
<span class="fc" id="L477">        }</span>

        @Override
        public String getText() {
<span class="fc" id="L481">            return text;</span>
        }

        @Override
        public String assumeText() {
<span class="fc bfc" id="L486" title="All 2 branches covered.">            if (text == null) {</span>
<span class="fc" id="L487">                throw new UnknownSymbolException(sid);</span>
            }
<span class="fc" id="L489">            return text;</span>
        }

        @Override
        public int getSid() {
<span class="fc" id="L494">            return sid;</span>
        }

        // Will be @Override once added to the SymbolToken interface.
        public ImportLocation getImportLocation() {
<span class="fc" id="L499">            return importLocation;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L504">            return String.format(&quot;SymbolToken::{text: %s, sid: %d, importLocation: %s}&quot;, text, sid, importLocation);</span>
        }

        @Override
        public boolean equals(Object o) {
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">            if (!(o instanceof SymbolToken)) return false;</span>

            // NOTE: once ImportLocation is available via the SymbolToken interface, it should be compared here
            // when text is null.
<span class="fc" id="L514">            SymbolToken other = (SymbolToken) o;</span>
<span class="pc bpc" id="L515" title="1 of 4 branches missed.">            if(getText() == null || other.getText() == null) {</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">                return getText() == other.getText();</span>
            }
<span class="fc" id="L518">            return getText().equals(other.getText());</span>
        }

        @Override
        public int hashCode() {
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">            if(getText() != null) return getText().hashCode();</span>
<span class="nc" id="L524">            return 0;</span>
        }
    }

    /**
     * Gets the system symbol table for the Ion version currently active.
     * @return a system SymbolTable.
     */
    private SymbolTable getSystemSymbolTable() {
        // Note: Ion 1.1 currently proposes changes to the system symbol table. If this is finalized, then
        // 'majorVersion' cannot be used to look up the system symbol table; both 'majorVersion' and 'minorVersion'
        // will need to be used.
<span class="fc" id="L536">        return SharedSymbolTable.getSystemSymbolTable(majorVersion);</span>
    }

    /**
     * Read-only snapshot of the local symbol table at the reader's current position.
     */
    private class LocalSymbolTableSnapshot implements SymbolTable, SymbolTableAsStruct {

        // The system symbol table.
<span class="fc" id="L545">        private final SymbolTable system = IonReaderBinaryIncremental.this.getSystemSymbolTable();</span>

        // The max ID of this local symbol table.
        private final int maxId;

        // The shared symbol tables imported by this local symbol table.
        private final LocalSymbolTableImports importedTables;

        // Map representation of this symbol table. Keys are symbol text; values are the lowest symbol ID that maps
        // to that text.
        final Map&lt;String, Integer&gt; mapView;

        // List representation of this symbol table, indexed by symbol ID.
        final List&lt;String&gt; listView;

<span class="fc" id="L560">        private SymbolTableStructCache structCache = null;</span>

<span class="fc" id="L562">        LocalSymbolTableSnapshot() {</span>
<span class="fc" id="L563">            int importsMaxId = imports.getMaxId();</span>
<span class="fc" id="L564">            int numberOfLocalSymbols = symbols.size();</span>
            // Note: 'imports' is immutable, so a clone is not needed.
<span class="fc" id="L566">            importedTables = imports;</span>
<span class="fc" id="L567">            maxId = importsMaxId + numberOfLocalSymbols;</span>
            // Map with initial size the number of symbols and load factor 1, meaning it must be full before growing.
            // It is not expected to grow.
<span class="fc" id="L570">            listView = new ArrayList&lt;String&gt;(symbols.subList(0, numberOfLocalSymbols));</span>
<span class="fc" id="L571">            mapView = new HashMap&lt;String, Integer&gt;((int) Math.ceil(numberOfLocalSymbols / 0.75), 0.75f);</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">            for (int i = 0; i &lt; numberOfLocalSymbols; i++) {</span>
<span class="fc" id="L573">                String symbol = listView.get(i);</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">                if (symbol != null) {</span>
<span class="fc" id="L575">                    mapView.put(symbol, i + importsMaxId + 1);</span>
                }
            }
<span class="fc" id="L578">        }</span>

        @Override
        public String getName() {
<span class="fc" id="L582">            return null;</span>
        }

        @Override
        public int getVersion() {
<span class="fc" id="L587">            return 0;</span>
        }

        @Override
        public boolean isLocalTable() {
<span class="fc" id="L592">            return true;</span>
        }

        @Override
        public boolean isSharedTable() {
<span class="fc" id="L597">            return false;</span>
        }

        @Override
        public boolean isSubstitute() {
<span class="fc" id="L602">            return false;</span>
        }

        @Override
        public boolean isSystemTable() {
<span class="fc" id="L607">            return false;</span>
        }

        @Override
        public SymbolTable getSystemSymbolTable() {
<span class="fc" id="L612">            return system;</span>
        }

        @Override
        public String getIonVersionId() {
<span class="fc" id="L617">            return system.getIonVersionId();</span>
        }

        @Override
        public SymbolTable[] getImportedTables() {
<span class="fc" id="L622">            return importedTables.getImportedTables();</span>
        }

        @Override
        public int getImportedMaxId() {
<span class="fc" id="L627">            return importedTables.getMaxId();</span>
        }

        @Override
        public SymbolToken find(String text) {
<span class="fc" id="L632">            SymbolToken token = importedTables.find(text);</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">            if (token != null) {</span>
<span class="fc" id="L634">                return token;</span>
            }
<span class="fc" id="L636">            Integer sid = mapView.get(text);</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">            if (sid == null) {</span>
<span class="fc" id="L638">                return null;</span>
            }
            // The following per-call allocation is intentional. When weighed against the alternative of making
            // 'mapView' a 'Map&lt;String, SymbolToken&gt;` instead of a `Map&lt;String, Integer&gt;`, the following points should
            // be considered:
            // 1. A LocalSymbolTableSnapshot is only created when getSymbolTable() is called on the reader. The reader
            // does not use the LocalSymbolTableSnapshot internally. There are two cases when getSymbolTable() would be
            // called: a) when the user calls it, which will basically never happen, and b) when the user uses
            // IonSystem.iterate over the reader, in which case each top-level value holds a reference to the symbol
            // table that was in scope when it occurred. In case a), in addition to rarely being called at all, it
            // would be even rarer for a user to use find() to retrieve each symbol (especially more than once) from the
            // returned symbol table. Case b) may be called more frequently, but it remains equally rare that a user
            // would retrieve each symbol at least once.
            // 2. If we make mapView a Map&lt;String, SymbolToken&gt;, then we are guaranteeing that we will allocate at least
            // one SymbolToken per symbol (because mapView is created in the constructor of LocalSymbolTableSnapshot)
            // even though it's unlikely most will ever be needed.
<span class="fc" id="L654">            return new SymbolTokenImpl(text, sid, null);</span>
        }

        @Override
        public int findSymbol(String name) {
<span class="fc" id="L659">            Integer sid = importedTables.findSymbol(name);</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">            if (sid &gt; UNKNOWN_SYMBOL_ID) {</span>
<span class="fc" id="L661">                return sid;</span>
            }
<span class="fc" id="L663">            sid = mapView.get(name);</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">            if (sid == null) {</span>
<span class="fc" id="L665">                return UNKNOWN_SYMBOL_ID;</span>
            }
<span class="fc" id="L667">            return sid;</span>
        }

        @Override
        public String findKnownSymbol(int id) {
<span class="fc bfc" id="L672" title="All 2 branches covered.">            if (id &lt; 0) {</span>
<span class="fc" id="L673">                throw new IllegalArgumentException(&quot;Symbol IDs must be at least 0.&quot;);</span>
            }
<span class="fc bfc" id="L675" title="All 2 branches covered.">            if (id &gt; getMaxId()) {</span>
<span class="fc" id="L676">                return null;</span>
            }
<span class="fc" id="L678">            return IonReaderBinaryIncremental.this.getSymbolString(id, importedTables, listView);</span>
        }

        @Override
        public Iterator&lt;String&gt; iterateDeclaredSymbolNames() {
<span class="fc" id="L683">            return new Iterator&lt;String&gt;() {</span>

<span class="fc" id="L685">                private int index = 0;</span>

                @Override
                public boolean hasNext() {
<span class="fc bfc" id="L689" title="All 2 branches covered.">                    return index &lt; listView.size();</span>
                }

                @Override
                public String next() {
<span class="fc" id="L694">                    String symbol = listView.get(index);</span>
<span class="fc" id="L695">                    index++;</span>
<span class="fc" id="L696">                    return symbol;</span>
                }

                @Override
                public void remove() {
<span class="nc" id="L701">                    throw new UnsupportedOperationException(&quot;This iterator does not support element removal.&quot;);</span>
                }
            };
        }

        @Override
        public SymbolToken intern(String text) {
<span class="fc" id="L708">            SymbolToken token = find(text);</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            if (token != null) {</span>
<span class="fc" id="L710">                return token;</span>
            }
<span class="fc" id="L712">            throw new ReadOnlyValueException();</span>
        }

        @Override
        public int getMaxId() {
<span class="fc" id="L717">            return maxId;</span>
        }

        @Override
        public boolean isReadOnly() {
<span class="fc" id="L722">            return true;</span>
        }

        @Override
        public void makeReadOnly() {
            // The symbol table is already read-only.
<span class="fc" id="L728">        }</span>

        @Override
        public void writeTo(IonWriter writer) throws IOException {
<span class="fc" id="L732">            IonReader reader = new SymbolTableReader(this);</span>
<span class="fc" id="L733">            writer.writeValues(reader);</span>
<span class="fc" id="L734">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L738">            return &quot;(LocalSymbolTable max_id:&quot; + getMaxId() + ')';</span>
        }

        @Override
        public IonStruct getIonRepresentation(ValueFactory valueFactory) {
<span class="fc bfc" id="L743" title="All 2 branches covered.">            if (structCache == null) {</span>
<span class="fc" id="L744">                structCache = new SymbolTableStructCache(this, getImportedTables(), null);</span>
            }
<span class="fc" id="L746">            return structCache.getIonRepresentation(valueFactory);</span>
        }
    }

    /**
     * Throw if the reader is attempting to process an Ion version that it does not support.
     */
    private void requireSupportedIonVersion() {
<span class="pc bpc" id="L754" title="1 of 4 branches missed.">        if (majorVersion != 1 || minorVersion != 0) {</span>
<span class="fc" id="L755">            throw new IonException(String.format(&quot;Unsupported Ion version: %d.%d&quot;, majorVersion, minorVersion));</span>
        }
<span class="fc" id="L757">    }</span>

    /**
     * Reset the local symbol table to the system symbol table.
     */
    private void resetSymbolTable() {
        // Note: when there is a new version of Ion, check majorVersion and minorVersion here and set the appropriate
        // system symbol table.
<span class="fc" id="L765">        symbols.clear();</span>
<span class="fc" id="L766">        cachedReadOnlySymbolTable = null;</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">        if (symbolTokensById != null) {</span>
<span class="fc" id="L768">            symbolTokensById.clear();</span>
        }
<span class="fc" id="L770">    }</span>

    /**
     * Resets the value's annotations.
     */
    private void resetAnnotations() {
<span class="fc" id="L776">        hasAnnotations = false;</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">        if (isAnnotationIteratorReuseEnabled) {</span>
<span class="fc" id="L778">            annotationIterator.invalidate();</span>
        }
<span class="fc" id="L780">    }</span>

    /**
     * Clear the list of imported shared symbol tables.
     */
    private void resetImports() {
        // Note: when support for the next version of Ion is added, conditionals on 'majorVersion' and 'minorVersion'
        // must be added here.
<span class="fc" id="L788">        imports = ION_1_0_IMPORTS;</span>
<span class="fc" id="L789">    }</span>

    /**
     * Creates a shared symbol table import, resolving it from the catalog if possible.
     * @param name the name of the shared symbol table.
     * @param version the version of the shared symbol table.
     * @param maxId the max_id of the shared symbol table. This value takes precedence over the actual max_id for the
     *              shared symbol table at the requested version.
     */
    private SymbolTable createImport(String name, int version, int maxId) {
<span class="fc" id="L799">        SymbolTable shared = catalog.getTable(name, version);</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">        if (shared == null) {</span>
            // No match. All symbol IDs that fall within this shared symbol table's range will have unknown text.
<span class="fc" id="L802">            return new SubstituteSymbolTable(name, version, maxId);</span>
<span class="fc bfc" id="L803" title="All 4 branches covered.">        } else if (shared.getMaxId() != maxId || shared.getVersion() != version) {</span>
            // Partial match. If the requested max_id exceeds the actual max_id of the resolved shared symbol table,
            // symbol IDs that exceed the max_id of the resolved shared symbol table will have unknown text.
<span class="fc" id="L806">            return new SubstituteSymbolTable(shared, version, maxId);</span>
        } else {
            // Exact match; the resolved shared symbol table may be used as-is.
<span class="fc" id="L809">            return shared;</span>
        }
    }

    /**
     * Gets the String representation of the given symbol ID. It is the caller's responsibility to ensure that the
     * given symbol ID is within the max ID of the symbol table.
     * @param sid the symbol ID.
     * @param importedSymbols the symbol table's shared symbol table imports.
     * @param localSymbols the symbol table's local symbols.
     * @return a String, which will be null if the requested symbol ID has undefined text.
     */
    private String getSymbolString(int sid, LocalSymbolTableImports importedSymbols, List&lt;String&gt; localSymbols) {
<span class="fc bfc" id="L822" title="All 2 branches covered.">        if (sid &lt;= importedSymbols.getMaxId()) {</span>
<span class="fc" id="L823">            return importedSymbols.findKnownSymbol(sid);</span>
        }
<span class="fc" id="L825">        return localSymbols.get(sid - (importedSymbols.getMaxId() + 1));</span>
    }

    /**
     * Calculates the symbol table's max ID.
     * @return the max ID.
     */
    private int maxSymbolId() {
<span class="fc" id="L833">        return symbols.size() + imports.getMaxId();</span>
    }

    /**
     * Retrieves the String text for the given symbol ID.
     * @param sid a symbol ID.
     * @return a String.
     */
    private String getSymbol(int sid) {
<span class="fc bfc" id="L842" title="All 2 branches covered.">        if (sid &gt; maxSymbolId()) {</span>
<span class="fc" id="L843">            throw new IonException(&quot;Symbol ID exceeds the max ID of the symbol table.&quot;);</span>
        }
<span class="fc" id="L845">        return getSymbolString(sid, imports, symbols);</span>
    }

    /**
     * Creates a SymbolToken representation of the given symbol ID.
     * @param sid a symbol ID.
     * @return a SymbolToken.
     */
    private SymbolToken getSymbolToken(int sid) {
<span class="fc" id="L854">        int symbolTableSize = maxSymbolId() + 1;</span>
<span class="fc bfc" id="L855" title="All 2 branches covered.">        if (symbolTokensById == null) {</span>
<span class="fc" id="L856">            symbolTokensById = new ArrayList&lt;SymbolToken&gt;(symbolTableSize);</span>
        }
<span class="fc bfc" id="L858" title="All 2 branches covered.">        if (symbolTokensById.size() &lt; symbolTableSize) {</span>
<span class="fc bfc" id="L859" title="All 2 branches covered.">            for (int i = symbolTokensById.size(); i &lt; symbolTableSize; i++) {</span>
<span class="fc" id="L860">                symbolTokensById.add(null);</span>
            }
        }
<span class="fc bfc" id="L863" title="All 2 branches covered.">        if (sid &gt;= symbolTableSize) {</span>
<span class="fc" id="L864">            throw new IonException(&quot;Symbol ID exceeds the max ID of the symbol table.&quot;);</span>
        }
<span class="fc" id="L866">        SymbolToken token = symbolTokensById.get(sid);</span>
<span class="fc bfc" id="L867" title="All 2 branches covered.">        if (token == null) {</span>
<span class="fc" id="L868">            String text = getSymbolString(sid, imports, symbols);</span>
<span class="fc" id="L869">            ImportLocation importLocation = null;</span>
<span class="fc bfc" id="L870" title="All 2 branches covered.">            if (text == null) {</span>
                // Note: this will never be a system symbol.
<span class="fc bfc" id="L872" title="All 4 branches covered.">                if (sid &gt; 0 &amp;&amp; sid &lt;= imports.getMaxId()) {</span>
<span class="fc" id="L873">                    importLocation = imports.getImportLocation(sid);</span>
                } else {
                    // All symbols with unknown text in the local symbol range are equivalent to symbol zero.
<span class="fc" id="L876">                    sid = 0;</span>
                }
            }
<span class="fc" id="L879">            token = new SymbolTokenImpl(text, sid, importLocation);</span>
<span class="fc" id="L880">            symbolTokensById.set(sid, token);</span>
        }
<span class="fc" id="L882">        return token;</span>
    }

    /**
     * Reads a local symbol table from the buffer.
     * @param marker marker for the start and end positions of the local symbol table in the buffer.
     */
    private void readSymbolTable(IonReaderLookaheadBuffer.Marker marker) {
<span class="fc" id="L890">        peekIndex = marker.startIndex;</span>
<span class="fc" id="L891">        boolean isAppend = false;</span>
<span class="fc" id="L892">        boolean hasSeenImports = false;</span>
<span class="fc" id="L893">        boolean hasSeenSymbols = false;</span>
<span class="fc" id="L894">        int symbolsPosition = -1;</span>
<span class="fc" id="L895">        int symbolsEndPosition = -1;</span>
        List&lt;SymbolTable&gt; newImports;
<span class="fc bfc" id="L897" title="All 2 branches covered.">        while (peekIndex &lt; marker.endIndex) {</span>
<span class="fc" id="L898">            fieldNameSid = readVarUInt();</span>
<span class="fc" id="L899">            IonTypeID typeID = readTypeId();</span>
<span class="fc" id="L900">            calculateEndPosition(typeID);</span>
<span class="fc" id="L901">            int currentValueEndPosition = valueEndPosition;</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">            if (fieldNameSid == SystemSymbolIDs.IMPORTS_ID) {</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">                if (hasSeenImports) {</span>
<span class="fc" id="L904">                    throw new IonException(&quot;Symbol table contained multiple imports fields.&quot;);</span>
                }
<span class="fc bfc" id="L906" title="All 2 branches covered.">                if (typeID.type == IonType.SYMBOL) {</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">                    isAppend = readUInt(peekIndex, currentValueEndPosition) == SystemSymbolIDs.ION_SYMBOL_TABLE_ID;</span>
<span class="fc" id="L908">                    peekIndex = currentValueEndPosition;</span>
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">                } else if (typeID.type == IonType.LIST) {</span>
<span class="fc" id="L910">                    resetImports();</span>
<span class="fc" id="L911">                    newImports = new ArrayList&lt;SymbolTable&gt;(3);</span>
<span class="fc" id="L912">                    newImports.add(getSystemSymbolTable());</span>
<span class="fc" id="L913">                    stepIn();</span>
<span class="fc" id="L914">                    IonType type = next();</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">                    while (type != null) {</span>
<span class="fc" id="L916">                        String name = null;</span>
<span class="fc" id="L917">                        int version = -1;</span>
<span class="fc" id="L918">                        int maxId = -1;</span>
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">                        if (type == IonType.STRUCT) {</span>
<span class="fc" id="L920">                            stepIn();</span>
<span class="fc" id="L921">                            type = next();</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">                            while (type != null) {</span>
<span class="fc" id="L923">                                int fieldSid = getFieldId();</span>
<span class="fc bfc" id="L924" title="All 2 branches covered.">                                if (fieldSid == SystemSymbolIDs.NAME_ID) {</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">                                    if (type == IonType.STRING) {</span>
<span class="fc" id="L926">                                        name = stringValue();</span>
                                    }
<span class="fc bfc" id="L928" title="All 2 branches covered.">                                } else if (fieldSid == SystemSymbolIDs.VERSION_ID) {</span>
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">                                    if (type == IonType.INT) {</span>
<span class="fc" id="L930">                                        version = intValue();</span>
                                    }
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">                                } else if (fieldSid == SystemSymbolIDs.MAX_ID_ID) {</span>
<span class="pc bpc" id="L933" title="1 of 2 branches missed.">                                    if (type == IonType.INT) {</span>
<span class="fc" id="L934">                                        maxId = intValue();</span>
                                    }
                                }
<span class="fc" id="L937">                                type = next();</span>
<span class="fc" id="L938">                            }</span>
<span class="fc" id="L939">                            stepOut();</span>
                        }
<span class="fc" id="L941">                        newImports.add(createImport(name, version, maxId));</span>
<span class="fc" id="L942">                        type = next();</span>
<span class="fc" id="L943">                    }</span>
<span class="fc" id="L944">                    stepOut();</span>
<span class="fc" id="L945">                    imports = new LocalSymbolTableImports(newImports);</span>
                }
<span class="fc bfc" id="L947" title="All 2 branches covered.">                if (!isAppend) {</span>
                    // Clear the existing symbols before adding the new imported symbols.
<span class="fc" id="L949">                    resetSymbolTable();</span>
                }
<span class="fc" id="L951">                hasSeenImports = true;</span>
<span class="pc bpc" id="L952" title="1 of 2 branches missed.">            } else if (fieldNameSid == SystemSymbolIDs.SYMBOLS_ID) {</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">                if (hasSeenSymbols) {</span>
<span class="fc" id="L954">                    throw new IonException(&quot;Symbol table contained multiple symbols fields.&quot;);</span>
                }
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">                if (typeID.type == IonType.LIST) {</span>
                    // Just record this position and skip forward. Come back after the imports (if any) are parsed.
<span class="fc" id="L958">                    symbolsPosition = peekIndex;</span>
<span class="fc" id="L959">                    symbolsEndPosition = currentValueEndPosition;</span>
                }
<span class="fc" id="L961">                hasSeenSymbols = true;</span>
            }
<span class="fc" id="L963">            peekIndex = currentValueEndPosition;</span>
<span class="fc" id="L964">        }</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">        if (!hasSeenImports) {</span>
<span class="fc" id="L966">            resetSymbolTable();</span>
<span class="fc" id="L967">            resetImports();</span>
        }
<span class="fc bfc" id="L969" title="All 2 branches covered.">        if (symbolsPosition &gt; -1) {</span>
<span class="fc" id="L970">            peekIndex = symbolsPosition;</span>
<span class="fc" id="L971">            valueType = IonType.LIST;</span>
<span class="fc" id="L972">            valueEndPosition = symbolsEndPosition;</span>
<span class="fc" id="L973">            stepIn();</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">            while (next() != null) {</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">                if (valueType != IonType.STRING) {</span>
<span class="fc" id="L976">                    symbols.add(null);</span>
                } else {
<span class="fc" id="L978">                    symbols.add(stringValue());</span>
                }
            }
<span class="fc" id="L981">            stepOut();</span>
<span class="fc" id="L982">            peekIndex = valueEndPosition;</span>
        }
<span class="fc" id="L984">    }</span>

    /**
     * Advance the reader to the next top-level value. Buffers an entire top-level value, reads any IVMs and/or local
     * symbol tables that precede the value, and sets the byte positions of important components of the value.
     */
    private void nextAtTopLevel() {
<span class="fc bfc" id="L991" title="All 2 branches covered.">        if (completeValueBuffered) {</span>
            // There is already data buffered, but the user is choosing to skip it.
<span class="fc" id="L993">            buffer.seekTo(valueEndPosition);</span>
<span class="fc" id="L994">            completeValueBuffered = false;</span>
        }
        try {
<span class="fc" id="L997">            lookahead.fillInput();</span>
<span class="fc" id="L998">        } catch (Exception e) {</span>
<span class="fc" id="L999">            throw new IonException(e);</span>
<span class="fc" id="L1000">        }</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">        if (lookahead.moreDataRequired()) {</span>
<span class="fc" id="L1002">            valueType = null;</span>
<span class="fc" id="L1003">            valueTypeID = null;</span>
<span class="fc" id="L1004">            return;</span>
        }
<span class="fc" id="L1006">        completeValueBuffered = true;</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">        if (lookahead.getIvmIndex() &gt; -1) {</span>
<span class="fc" id="L1008">            peekIndex = lookahead.getIvmIndex();</span>
<span class="fc" id="L1009">            majorVersion = buffer.peek(peekIndex++);</span>
<span class="fc" id="L1010">            minorVersion = buffer.peek(peekIndex++);</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">            if (buffer.peek(peekIndex++) != IVM_FINAL_BYTE) {</span>
<span class="fc" id="L1012">                throw new IonException(&quot;Invalid Ion version marker.&quot;);</span>
            }
<span class="fc" id="L1014">            requireSupportedIonVersion();</span>
<span class="fc" id="L1015">            resetSymbolTable();</span>
<span class="fc" id="L1016">            resetImports();</span>
<span class="fc" id="L1017">            lookahead.resetIvmIndex();</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        } else if (peekIndex &lt; 0) {</span>
            // peekIndex is initialized to -1 and only increases. This branch is reached if the IVM does not occur
            // first in the stream. This is necessary because currently a binary incremental reader will be created if
            // an empty stream is provided to the IonReaderBuilder. If, once bytes appear in the stream, those bytes do
            // not represent valid binary Ion, a quick failure is necessary.
<span class="fc" id="L1023">            throw new IonException(&quot;Binary Ion must start with an Ion version marker.&quot;);</span>
        }
<span class="fc" id="L1025">        List&lt;IonReaderLookaheadBuffer.Marker&gt; symbolTableMarkers = lookahead.getSymbolTableMarkers();</span>
<span class="fc bfc" id="L1026" title="All 2 branches covered.">        if (!symbolTableMarkers.isEmpty()) {</span>
            // The cached SymbolTable (if any) is a snapshot in time, so it must be cleared whenever a new symbol
            // table is read regardless of whether the new LST is an append or a reset.
<span class="fc" id="L1029">            cachedReadOnlySymbolTable = null;</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">            for (IonReaderLookaheadBuffer.Marker symbolTableMarker : symbolTableMarkers) {</span>
<span class="fc" id="L1031">                readSymbolTable(symbolTableMarker);</span>
<span class="fc" id="L1032">            }</span>
<span class="fc" id="L1033">            lookahead.resetSymbolTableMarkers();</span>
        }
<span class="fc" id="L1035">        peekIndex = lookahead.getValueStart();</span>
<span class="fc" id="L1036">        hasAnnotations = lookahead.hasAnnotations();</span>
<span class="fc bfc" id="L1037" title="All 2 branches covered.">        if (hasAnnotations) {</span>
<span class="fc bfc" id="L1038" title="All 2 branches covered.">            if (peekIndex &gt;= lookahead.getValueEnd()) {</span>
<span class="fc" id="L1039">                throw new IonException(&quot;Annotation wrappers without values are invalid.&quot;);</span>
            }
<span class="fc" id="L1041">            annotationSids.clear();</span>
<span class="fc" id="L1042">            IonReaderLookaheadBuffer.Marker annotationSidsMarker = lookahead.getAnnotationSidsMarker();</span>
<span class="fc" id="L1043">            annotationStartPosition = annotationSidsMarker.startIndex;</span>
<span class="fc" id="L1044">            annotationEndPosition = annotationSidsMarker.endIndex;</span>
<span class="fc" id="L1045">            peekIndex = annotationEndPosition;</span>
<span class="fc" id="L1046">            valueTypeID = IonTypeID.TYPE_IDS[buffer.peek(peekIndex++)];</span>
<span class="fc" id="L1047">            int wrappedValueLength = valueTypeID.length;</span>
<span class="fc bfc" id="L1048" title="All 2 branches covered.">            if (valueTypeID.variableLength) {</span>
<span class="fc" id="L1049">                wrappedValueLength = readVarUInt();</span>
            }
<span class="fc" id="L1051">            valueType = valueTypeID.type;</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">            if (valueType == IonTypeID.ION_TYPE_ANNOTATION_WRAPPER) {</span>
<span class="fc" id="L1053">                throw new IonException(&quot;Nested annotations are invalid.&quot;);</span>
            }
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            if (peekIndex + wrappedValueLength != lookahead.getValueEnd()) {</span>
<span class="fc" id="L1056">                throw new IonException(&quot;Mismatched annotation wrapper length.&quot;);</span>
            }
<span class="fc" id="L1058">        } else {</span>
<span class="fc" id="L1059">            valueTypeID = lookahead.getValueTid();</span>
<span class="fc" id="L1060">            valueType = valueTypeID.type;</span>
        }
<span class="fc" id="L1062">        valueStartPosition = peekIndex;</span>
<span class="fc" id="L1063">        valueEndPosition = lookahead.getValueEnd();</span>
<span class="fc" id="L1064">        lookahead.resetNopPadIndex();</span>
<span class="fc" id="L1065">    }</span>

    /**
     * Reads the type ID byte.
     * @return the TypeAndLength descriptor for the type ID byte.
     */
    private IonTypeID readTypeId() {
<span class="fc" id="L1072">        valueTypeID = IonTypeID.TYPE_IDS[buffer.peek(peekIndex++)];</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">        if (!valueTypeID.isValid) {</span>
<span class="fc" id="L1074">            throw new IonException(&quot;Invalid type ID.&quot;);</span>
        }
<span class="fc" id="L1076">        valueType = valueTypeID.type;</span>
<span class="fc" id="L1077">        return valueTypeID;</span>
    }

    /**
     * Calculates the end position for the given type ID descriptor.
     * @param typeID the type ID descriptor.
     */
    private void calculateEndPosition(IonTypeID typeID) {
<span class="fc bfc" id="L1085" title="All 2 branches covered.">        if (typeID.variableLength) {</span>
<span class="fc" id="L1086">            valueEndPosition = readVarUInt() + peekIndex;</span>
        } else {
<span class="fc" id="L1088">            valueEndPosition = typeID.length + peekIndex;</span>
        }
<span class="fc" id="L1090">    }</span>

    @Override
    public boolean hasNext() {
<span class="nc" id="L1094">        throw new UnsupportedOperationException(&quot;Not implemented&quot;);</span>
    }

    /**
     * Marks the end of the current container by indicating that the reader is no longer positioned on a value.
     */
    private void endContainer() {
<span class="fc" id="L1101">        valueType = null;</span>
<span class="fc" id="L1102">        valueTypeID = null;</span>
<span class="fc" id="L1103">        annotationStartPosition = -1;</span>
<span class="fc" id="L1104">        annotationEndPosition = -1;</span>
<span class="fc" id="L1105">        hasAnnotations = false;</span>
<span class="fc" id="L1106">    }</span>

    /**
     * Advance the reader to the next value within a container, which must already be buffered.
     */
    private void nextBelowTopLevel() {
        // Seek past the previous value.
<span class="fc bfc" id="L1113" title="All 2 branches covered.">        if (peekIndex &lt; valueEndPosition) {</span>
<span class="fc" id="L1114">            peekIndex = valueEndPosition;</span>
        }
<span class="fc bfc" id="L1116" title="All 2 branches covered.">        if (peekIndex &gt;= containerStack.peek().endPosition) {</span>
<span class="fc" id="L1117">            endContainer();</span>
        } else {
<span class="fc bfc" id="L1119" title="All 2 branches covered.">            if (containerStack.peek().type == IonType.STRUCT) {</span>
<span class="fc" id="L1120">                fieldNameSid = readVarUInt();</span>
            }
<span class="fc" id="L1122">            IonTypeID typeID = readTypeId();</span>
<span class="fc bfc" id="L1123" title="All 2 branches covered.">            while (typeID.isNopPad) {</span>
<span class="fc" id="L1124">                calculateEndPosition(typeID);</span>
<span class="fc" id="L1125">                peekIndex = valueEndPosition;</span>
<span class="fc bfc" id="L1126" title="All 2 branches covered.">                if (peekIndex &gt;= containerStack.peek().endPosition) {</span>
<span class="fc" id="L1127">                    endContainer();</span>
<span class="fc" id="L1128">                    return;</span>
                }
<span class="pc bpc" id="L1130" title="1 of 2 branches missed.">                if (containerStack.peek().type == IonType.STRUCT) {</span>
<span class="fc" id="L1131">                    fieldNameSid = readVarUInt();</span>
                }
<span class="fc" id="L1133">                typeID = readTypeId();</span>
            }
<span class="fc" id="L1135">            calculateEndPosition(typeID);</span>
<span class="fc bfc" id="L1136" title="All 2 branches covered.">            if (valueType == IonTypeID.ION_TYPE_ANNOTATION_WRAPPER) {</span>
<span class="fc" id="L1137">                hasAnnotations = true;</span>
<span class="fc" id="L1138">                annotationSids.clear();</span>
<span class="fc" id="L1139">                int annotationsLength = readVarUInt();</span>
<span class="fc" id="L1140">                annotationStartPosition = peekIndex;</span>
<span class="fc" id="L1141">                annotationEndPosition = annotationStartPosition + annotationsLength;</span>
<span class="fc" id="L1142">                peekIndex = annotationEndPosition;</span>
<span class="fc" id="L1143">                typeID = readTypeId();</span>
<span class="fc bfc" id="L1144" title="All 2 branches covered.">                if (typeID.isNopPad) {</span>
<span class="fc" id="L1145">                    throw new IonException(</span>
                        &quot;Invalid annotation wrapper: NOP pad may not occur inside an annotation wrapper.&quot;
                    );
                }
<span class="fc bfc" id="L1149" title="All 2 branches covered.">                if (valueType == IonTypeID.ION_TYPE_ANNOTATION_WRAPPER) {</span>
<span class="fc" id="L1150">                    throw new IonException(&quot;Nested annotations are invalid.&quot;);</span>
                }
<span class="fc" id="L1152">                long annotationWrapperEndPosition = valueEndPosition;</span>
<span class="fc" id="L1153">                calculateEndPosition(typeID);</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">                if (annotationWrapperEndPosition != valueEndPosition) {</span>
<span class="fc" id="L1155">                    throw new IonException(</span>
                        &quot;Invalid annotation wrapper: end of the wrapper did not match end of the value.&quot;
                    );
                }
<span class="fc" id="L1159">            } else {</span>
<span class="fc" id="L1160">                annotationStartPosition = -1;</span>
<span class="fc" id="L1161">                annotationEndPosition = -1;</span>
<span class="fc" id="L1162">                hasAnnotations = false;</span>
<span class="fc bfc" id="L1163" title="All 2 branches covered.">                if (valueEndPosition &gt; containerStack.peek().endPosition) {</span>
<span class="fc" id="L1164">                    throw new IonException(&quot;Value overflowed its container.&quot;);</span>
                }
            }
<span class="pc bpc" id="L1167" title="1 of 2 branches missed.">            if (!valueTypeID.isValid) {</span>
<span class="nc" id="L1168">                throw new IonException(&quot;Invalid type ID.&quot;);</span>
            }
<span class="fc" id="L1170">            valueStartPosition = peekIndex;</span>
        }
<span class="fc" id="L1172">    }</span>

    @Override
    public IonType next() {
<span class="fc" id="L1176">        fieldNameSid = -1;</span>
<span class="fc" id="L1177">        lobBytesRead = 0;</span>
<span class="fc" id="L1178">        valueStartPosition = -1;</span>
<span class="fc" id="L1179">        resetAnnotations();</span>
<span class="fc bfc" id="L1180" title="All 2 branches covered.">        if (containerStack.isEmpty()) {</span>
<span class="fc" id="L1181">            nextAtTopLevel();</span>
        } else {
<span class="fc" id="L1183">            nextBelowTopLevel();</span>
        }
        // Note: the following check is necessary to catch empty ordered structs, which are prohibited by the spec.
        // Unfortunately, this requires a check on every value for a condition that will probably never happen.
<span class="fc bfc" id="L1187" title="All 6 branches covered.">        if (</span>
            valueType == IonType.STRUCT &amp;&amp;
            valueTypeID.lowerNibble == IonTypeID.ORDERED_STRUCT_NIBBLE &amp;&amp;
            valueStartPosition == valueEndPosition
        ) {
<span class="fc" id="L1192">            throw new IonException(&quot;Ordered struct must not be empty.&quot;);</span>
        }
<span class="fc" id="L1194">        return valueType;</span>
    }

    @Override
    public void stepIn() {
<span class="fc bfc" id="L1199" title="All 2 branches covered.">        if (!IonType.isContainer(valueType)) {</span>
<span class="fc" id="L1200">            throw new IonException(&quot;Must be positioned on a container to step in.&quot;);</span>
        }
        // Note: the IonReader interface dictates that stepping into a null container has the same behavior as
        // an empty container.
<span class="fc" id="L1204">        ContainerInfo containerInfo = containerStack.push();</span>
<span class="fc" id="L1205">        containerInfo.type = valueType;</span>
<span class="fc" id="L1206">        containerInfo.endPosition = valueEndPosition;</span>
<span class="fc" id="L1207">        valueType = null;</span>
<span class="fc" id="L1208">        valueTypeID = null;</span>
<span class="fc" id="L1209">        valueEndPosition = -1;</span>
<span class="fc" id="L1210">        fieldNameSid = -1;</span>
<span class="fc" id="L1211">        valueStartPosition = -1;</span>
<span class="fc" id="L1212">    }</span>

    @Override
    public void stepOut() {
<span class="fc bfc" id="L1216" title="All 2 branches covered.">        if (containerStack.isEmpty()) {</span>
            // Note: this is IllegalStateException for consistency with the other binary IonReader implementation.
<span class="fc" id="L1218">            throw new IllegalStateException(&quot;Cannot step out at top level.&quot;);</span>
        }
<span class="fc" id="L1220">        ContainerInfo containerInfo = containerStack.pop();</span>
<span class="fc" id="L1221">        valueEndPosition = containerInfo.endPosition;</span>
<span class="fc" id="L1222">        valueType = null;</span>
<span class="fc" id="L1223">        valueTypeID = null;</span>
<span class="fc" id="L1224">        fieldNameSid = -1;</span>
<span class="fc" id="L1225">        valueStartPosition = -1;</span>
<span class="fc" id="L1226">    }</span>

    @Override
    public int getDepth() {
<span class="fc" id="L1230">        return containerStack.size();</span>
    }

    @Override
    public SymbolTable getSymbolTable() {
<span class="fc bfc" id="L1235" title="All 2 branches covered.">        if (cachedReadOnlySymbolTable == null) {</span>
<span class="fc bfc" id="L1236" title="All 4 branches covered.">            if (symbols.size() == 0 &amp;&amp; imports == ION_1_0_IMPORTS) {</span>
<span class="fc" id="L1237">                cachedReadOnlySymbolTable = imports.getSystemSymbolTable();</span>
            } else {
<span class="fc" id="L1239">                cachedReadOnlySymbolTable = new LocalSymbolTableSnapshot();</span>
            }
        }
<span class="fc" id="L1242">        return cachedReadOnlySymbolTable;</span>
    }

    @Override
    public SymbolTable pop_passed_symbol_table() {
<span class="fc" id="L1247">        SymbolTable currentSymbolTable = getSymbolTable();</span>
<span class="fc bfc" id="L1248" title="All 2 branches covered.">        if (currentSymbolTable == symbolTableLastTransferred) {</span>
            // This symbol table has already been returned. Since the contract is that it is a &quot;pop&quot;, it should not
            // be returned twice.
<span class="fc" id="L1251">            return null;</span>
        }
<span class="fc" id="L1253">        symbolTableLastTransferred = currentSymbolTable;</span>
<span class="fc" id="L1254">        return symbolTableLastTransferred;</span>
    }

    @Override
    public IonType getType() {
<span class="fc" id="L1259">        return valueType;</span>
    }

    @Override
    public IntegerSize getIntegerSize() {
<span class="fc bfc" id="L1264" title="All 4 branches covered.">        if (valueType != IonType.INT || isNullValue()) {</span>
<span class="fc" id="L1265">            return null;</span>
        }
<span class="fc bfc" id="L1267" title="All 2 branches covered.">        if (valueTypeID.length &lt; INT_SIZE_IN_BYTES) {</span>
            // Note: this is conservative. Most integers of size 4 also fit in an int, but since exactly the
            // same parsing code is used for ints and longs, there is no point wasting the time to determine the
            // smallest possible type.
<span class="fc" id="L1271">            return IntegerSize.INT;</span>
<span class="fc bfc" id="L1272" title="All 2 branches covered.">        } else if (valueTypeID.length &lt; LONG_SIZE_IN_BYTES) {</span>
<span class="fc" id="L1273">            return IntegerSize.LONG;</span>
<span class="fc bfc" id="L1274" title="All 2 branches covered.">        } else if (valueTypeID.length == LONG_SIZE_IN_BYTES) {</span>
            // Because creating BigIntegers is so expensive, it is worth it to look ahead and determine exactly
            // which 8-byte integers can fit in a long.
<span class="fc bfc" id="L1277" title="All 2 branches covered.">            if (valueTypeID.isNegativeInt) {</span>
                // The smallest negative 8-byte integer that can fit in a long is -0x80_00_00_00_00_00_00_00.
<span class="fc" id="L1279">                int firstByte = buffer.peek(valueStartPosition);</span>
<span class="fc bfc" id="L1280" title="All 2 branches covered.">                if (firstByte &lt; MOST_SIGNIFICANT_BYTE_OF_MIN_LONG) {</span>
<span class="fc" id="L1281">                    return IntegerSize.LONG;</span>
<span class="fc bfc" id="L1282" title="All 2 branches covered.">                } else if (firstByte &gt; MOST_SIGNIFICANT_BYTE_OF_MIN_LONG) {</span>
<span class="fc" id="L1283">                    return IntegerSize.BIG_INTEGER;</span>
                }
<span class="fc bfc" id="L1285" title="All 2 branches covered.">                for (int i = valueStartPosition + 1; i &lt; valueEndPosition; i++) {</span>
<span class="fc bfc" id="L1286" title="All 2 branches covered.">                    if (0x00 != buffer.peek(i)) {</span>
<span class="fc" id="L1287">                        return IntegerSize.BIG_INTEGER;</span>
                    }
                }
<span class="fc" id="L1290">            } else {</span>
                // The largest positive 8-byte integer that can fit in a long is 0x7F_FF_FF_FF_FF_FF_FF_FF.
<span class="fc bfc" id="L1292" title="All 2 branches covered.">                if (buffer.peek(valueStartPosition) &gt; MOST_SIGNIFICANT_BYTE_OF_MAX_LONG) {</span>
<span class="fc" id="L1293">                    return IntegerSize.BIG_INTEGER;</span>
                }
            }
<span class="fc" id="L1296">            return IntegerSize.LONG;</span>
        }
<span class="fc" id="L1298">        return IntegerSize.BIG_INTEGER;</span>
    }

    /**
     * Require that the given type matches the type of the current value.
     * @param required the required type of current value.
     */
    private void requireType(IonType required) {
<span class="fc bfc" id="L1306" title="All 2 branches covered.">        if (required != valueType) {</span>
            // Note: this is IllegalStateException to match the behavior of the other binary IonReader implementation.
<span class="fc" id="L1308">            throw new IllegalStateException(</span>
<span class="fc" id="L1309">                String.format(&quot;Invalid type. Required %s but found %s.&quot;, required, valueType)</span>
            );
        }
<span class="fc" id="L1312">    }</span>

    /**
     * Reads a VarUInt.
     * @return the value.
     */
    private int readVarUInt() {
<span class="fc" id="L1319">        int currentByte = 0;</span>
<span class="fc" id="L1320">        int result = 0;</span>
<span class="fc bfc" id="L1321" title="All 2 branches covered.">        while ((currentByte &amp; HIGHEST_BIT_BITMASK) == 0) {</span>
<span class="fc" id="L1322">            currentByte = buffer.peek(peekIndex++);</span>
<span class="fc" id="L1323">            result = (result &lt;&lt; VALUE_BITS_PER_VARUINT_BYTE) | (currentByte &amp; LOWER_SEVEN_BITS_BITMASK);</span>
        }
<span class="fc" id="L1325">        return result;</span>
    }

    /**
     * Reads a UInt.
     * @param limit the position of the first byte after the end of the UInt value.
     * @return the value.
     */
    private long readUInt(int startIndex, int limit) {
<span class="fc" id="L1334">        long result = 0;</span>
<span class="fc bfc" id="L1335" title="All 2 branches covered.">        for (int i = startIndex; i &lt; limit; i++) {</span>
<span class="fc" id="L1336">            result = (result &lt;&lt; VALUE_BITS_PER_UINT_BYTE) | buffer.peek(i);</span>
        }
<span class="fc" id="L1338">        return result;</span>
    }

    /**
     * Reads a UInt starting at `valueStartPosition` and ending at `valueEndPosition`.
     * @return the value.
     */
    private long readUInt() {
<span class="fc" id="L1346">        return readUInt(valueStartPosition, valueEndPosition);</span>
    }

    /**
     * Reads a VarInt.
     * @param firstByte the first byte of the VarInt representation, which has already been retrieved from the buffer.
     * @return the value.
     */
    private int readVarInt(int firstByte) {
<span class="fc" id="L1355">        int currentByte = firstByte;</span>
<span class="fc bfc" id="L1356" title="All 2 branches covered.">        int sign = (currentByte &amp; VAR_INT_SIGN_BITMASK) == 0 ? 1 : -1;</span>
<span class="fc" id="L1357">        int result = currentByte &amp; LOWER_SIX_BITS_BITMASK;</span>
<span class="fc bfc" id="L1358" title="All 2 branches covered.">        while ((currentByte &amp; HIGHEST_BIT_BITMASK) == 0) {</span>
<span class="fc" id="L1359">            currentByte = buffer.peek(peekIndex++);</span>
<span class="fc" id="L1360">            result = (result &lt;&lt; VALUE_BITS_PER_VARUINT_BYTE) | (currentByte &amp; LOWER_SEVEN_BITS_BITMASK);</span>
        }
<span class="fc" id="L1362">        return result * sign;</span>
    }

    /**
     * Reads a VarInt.
     * @return the value.
     */
    private int readVarInt() {
<span class="fc" id="L1370">        return readVarInt(buffer.peek(peekIndex++));</span>
    }

    // Scratch space for various byte sizes. Only for use while computing a single value.
<span class="fc" id="L1374">    private static final byte[][] SCRATCH_FOR_SIZE = new byte[][] {</span>
        new byte[0],
        new byte[1],
        new byte[2],
        new byte[3],
        new byte[4],
        new byte[5],
        new byte[6],
        new byte[7],
        new byte[8],
        new byte[9],
        new byte[10],
        new byte[11],
        new byte[12],
    };

    /**
     * Copy the requested number of bytes from the buffer into a scratch buffer of exactly the requested length.
     * @param startIndex the start index from which to copy.
     * @param length the number of bytes to copy.
     * @return the scratch byte array.
     */
    private byte[] copyBytesToScratch(int startIndex, int length) {
        // Note: using reusable scratch buffers makes reading ints and decimals 1-5% faster and causes much less
        // GC churn.
<span class="fc" id="L1399">        byte[] bytes = null;</span>
<span class="fc bfc" id="L1400" title="All 2 branches covered.">        if (length &lt; SCRATCH_FOR_SIZE.length) {</span>
<span class="fc" id="L1401">            bytes = SCRATCH_FOR_SIZE[length];</span>
        }
<span class="fc bfc" id="L1403" title="All 2 branches covered.">        if (bytes == null) {</span>
<span class="fc" id="L1404">            bytes = new byte[length];</span>
        }
        // The correct number of bytes will be requested from the buffer, so the limit is set at the capacity to
        // avoid having to calculate a limit.
<span class="fc" id="L1408">        buffer.copyBytes(startIndex, bytes, 0, bytes.length);</span>
<span class="fc" id="L1409">        return bytes;</span>
    }

    /**
     * Reads a UInt value into a BigInteger.
     * @param isNegative true if the resulting BigInteger value should be negative; false if it should be positive.
     * @return the value.
     */
    private BigInteger readUIntAsBigInteger(boolean isNegative) {
<span class="fc" id="L1418">        int length = valueEndPosition - valueStartPosition;</span>
        // NOTE: unfortunately, there is no BigInteger(int signum, byte[] bits, int offset, int length) constructor
        // until JDK 9, so copying to scratch space is always required. Migrating to the new constructor will
        // lead to a significant performance improvement.
<span class="fc" id="L1422">        byte[] magnitude = copyBytesToScratch(valueStartPosition, length);</span>
<span class="fc bfc" id="L1423" title="All 2 branches covered.">        int signum = isNegative ? -1 : 1;</span>
<span class="fc" id="L1424">        return new BigInteger(signum, magnitude);</span>
    }

    /**
     * Get and clear the most significant bit in the given byte array.
     * @param intBytes bytes representing a signed int.
     * @return -1 if the most significant bit was set; otherwise, 1.
     */
    private int getAndClearSignBit(byte[] intBytes) {
<span class="fc bfc" id="L1433" title="All 2 branches covered.">        boolean isNegative = (intBytes[0] &amp; HIGHEST_BIT_BITMASK) != 0;</span>
<span class="fc bfc" id="L1434" title="All 2 branches covered.">        int signum = isNegative ? -1 : 1;</span>
<span class="fc bfc" id="L1435" title="All 2 branches covered.">        if (isNegative) {</span>
<span class="fc" id="L1436">            intBytes[0] &amp;= LOWER_SEVEN_BITS_BITMASK;</span>
        }
<span class="fc" id="L1438">        return signum;</span>
    }

    /**
     * Reads an Int value into a BigInteger.
     * @param limit the position of the first byte after the end of the UInt value.
     * @return the value.
     */
    private BigInteger readIntAsBigInteger(int limit) {
        BigInteger value;
<span class="fc" id="L1448">        int length = limit - peekIndex;</span>
<span class="fc bfc" id="L1449" title="All 2 branches covered.">        if (length &gt; 0) {</span>
            // NOTE: unfortunately, there is no BigInteger(int signum, byte[] bits, int offset, int length) constructor
            // until JDK 9, so copying to scratch space is always required. Migrating to the new constructor will
            // lead to a significant performance improvement.
<span class="fc" id="L1453">            byte[] bytes = copyBytesToScratch(peekIndex, length);</span>
<span class="fc" id="L1454">            value = new BigInteger(getAndClearSignBit(bytes), bytes);</span>
<span class="fc" id="L1455">        }</span>
        else {
<span class="fc" id="L1457">            value = BigInteger.ZERO;</span>
        }
<span class="fc" id="L1459">        return value;</span>
    }

    @Override
    public long longValue() {
        long value;
<span class="fc bfc" id="L1465" title="All 2 branches covered.">        if (valueType == IonType.INT) {</span>
<span class="fc bfc" id="L1466" title="All 2 branches covered.">            if (valueTypeID.length == 0) {</span>
<span class="fc" id="L1467">                return 0;</span>
            }
<span class="fc" id="L1469">            value = readUInt();</span>
<span class="fc bfc" id="L1470" title="All 2 branches covered.">            if (valueTypeID.isNegativeInt) {</span>
<span class="fc bfc" id="L1471" title="All 2 branches covered.">                if (value == 0) {</span>
<span class="fc" id="L1472">                    throw new IonException(&quot;Int zero may not be negative.&quot;);</span>
                }
<span class="fc" id="L1474">                value *= -1;</span>
            }
<span class="fc bfc" id="L1476" title="All 2 branches covered.">        } else if (valueType == IonType.FLOAT) {</span>
<span class="fc" id="L1477">            scalarConverter.addValue(doubleValue());</span>
<span class="fc" id="L1478">            scalarConverter.setAuthoritativeType(_Private_ScalarConversions.AS_TYPE.double_value);</span>
<span class="fc" id="L1479">            scalarConverter.cast(scalarConverter.get_conversion_fnid(_Private_ScalarConversions.AS_TYPE.long_value));</span>
<span class="fc" id="L1480">            value = scalarConverter.getLong();</span>
<span class="fc" id="L1481">            scalarConverter.clear();</span>
<span class="fc bfc" id="L1482" title="All 2 branches covered.">        } else if (valueType == IonType.DECIMAL) {</span>
<span class="fc" id="L1483">            scalarConverter.addValue(decimalValue());</span>
<span class="fc" id="L1484">            scalarConverter.setAuthoritativeType(_Private_ScalarConversions.AS_TYPE.decimal_value);</span>
<span class="fc" id="L1485">            scalarConverter.cast(scalarConverter.get_conversion_fnid(_Private_ScalarConversions.AS_TYPE.long_value));</span>
<span class="fc" id="L1486">            value = scalarConverter.getLong();</span>
<span class="fc" id="L1487">            scalarConverter.clear();</span>
        } else {
<span class="fc" id="L1489">            throw new IllegalStateException(&quot;longValue() may only be called on values of type int, float, or decimal.&quot;);</span>
        }
<span class="fc" id="L1491">        return value;</span>
    }

    @Override
    public BigInteger bigIntegerValue() {
        BigInteger value;
<span class="fc bfc" id="L1497" title="All 2 branches covered.">        if (valueType == IonType.INT) {</span>
<span class="fc bfc" id="L1498" title="All 2 branches covered.">            if (isNullValue()) {</span>
                // NOTE: this mimics existing behavior, but should probably be undefined (as, e.g., longValue() is in this
                //  case).
<span class="fc" id="L1501">                return null;</span>
            }
<span class="fc bfc" id="L1503" title="All 2 branches covered.">            if (valueTypeID.length == 0) {</span>
<span class="fc" id="L1504">                return BigInteger.ZERO;</span>
            }
<span class="fc" id="L1506">            value = readUIntAsBigInteger(valueTypeID.isNegativeInt);</span>
<span class="fc bfc" id="L1507" title="All 4 branches covered.">            if (valueTypeID.isNegativeInt &amp;&amp; value.signum() == 0) {</span>
<span class="fc" id="L1508">                throw new IonException(&quot;Int zero may not be negative.&quot;);</span>
            }
<span class="fc bfc" id="L1510" title="All 2 branches covered.">        } else if (valueType == IonType.FLOAT) {</span>
<span class="fc bfc" id="L1511" title="All 2 branches covered.">            if (isNullValue()) {</span>
<span class="fc" id="L1512">                value = null;</span>
            } else {
<span class="fc" id="L1514">                scalarConverter.addValue(doubleValue());</span>
<span class="fc" id="L1515">                scalarConverter.setAuthoritativeType(_Private_ScalarConversions.AS_TYPE.double_value);</span>
<span class="fc" id="L1516">                scalarConverter.cast(scalarConverter.get_conversion_fnid(_Private_ScalarConversions.AS_TYPE.bigInteger_value));</span>
<span class="fc" id="L1517">                value = scalarConverter.getBigInteger();</span>
<span class="fc" id="L1518">                scalarConverter.clear();</span>
            }
<span class="fc bfc" id="L1520" title="All 2 branches covered.">        } else if (valueType == IonType.DECIMAL) {</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">            if (isNullValue()) {</span>
<span class="fc" id="L1522">                value = null;</span>
            } else {
<span class="fc" id="L1524">                scalarConverter.addValue(decimalValue());</span>
<span class="fc" id="L1525">                scalarConverter.setAuthoritativeType(_Private_ScalarConversions.AS_TYPE.decimal_value);</span>
<span class="fc" id="L1526">                scalarConverter.cast(scalarConverter.get_conversion_fnid(_Private_ScalarConversions.AS_TYPE.bigInteger_value));</span>
<span class="fc" id="L1527">                value = scalarConverter.getBigInteger();</span>
<span class="fc" id="L1528">                scalarConverter.clear();</span>
            }
        } else {
<span class="fc" id="L1531">            throw new IllegalStateException(&quot;longValue() may only be called on values of type int, float, or decimal.&quot;);</span>
        }
<span class="fc" id="L1533">        return value;</span>
    }

    @Override
    public Date dateValue() {
<span class="fc" id="L1538">        Timestamp timestamp = timestampValue();</span>
<span class="fc bfc" id="L1539" title="All 2 branches covered.">        if (timestamp == null) {</span>
<span class="fc" id="L1540">            return null;</span>
        }
<span class="fc" id="L1542">        return timestamp.dateValue();</span>
    }

    @Override
    public int intValue() {
<span class="fc" id="L1547">        return (int) longValue();</span>
    }

    @Override
    public double doubleValue() {
        double value;
<span class="fc bfc" id="L1553" title="All 2 branches covered.">        if (valueType == IonType.FLOAT) {</span>
<span class="fc" id="L1554">            int length = valueEndPosition - valueStartPosition;</span>
<span class="fc bfc" id="L1555" title="All 2 branches covered.">            if (length == 0) {</span>
<span class="fc" id="L1556">                return 0.0d;</span>
            }
<span class="fc" id="L1558">            ByteBuffer bytes = buffer.getByteBuffer(valueStartPosition, valueEndPosition);</span>
<span class="fc bfc" id="L1559" title="All 2 branches covered.">            if (length == FLOAT_32_BYTE_LENGTH) {</span>
<span class="fc" id="L1560">                value = bytes.getFloat();</span>
            } else {
                // Note: there is no need to check for other lengths here; the type ID byte is validated during next().
<span class="fc" id="L1563">                value = bytes.getDouble();</span>
            }
<span class="fc bfc" id="L1565" title="All 2 branches covered.">        }  else if (valueType == IonType.DECIMAL) {</span>
<span class="fc" id="L1566">            scalarConverter.addValue(decimalValue());</span>
<span class="fc" id="L1567">            scalarConverter.setAuthoritativeType(_Private_ScalarConversions.AS_TYPE.decimal_value);</span>
<span class="fc" id="L1568">            scalarConverter.cast(scalarConverter.get_conversion_fnid(_Private_ScalarConversions.AS_TYPE.double_value));</span>
<span class="fc" id="L1569">            value = scalarConverter.getDouble();</span>
<span class="fc" id="L1570">            scalarConverter.clear();</span>
        } else {
<span class="fc" id="L1572">            throw new IllegalStateException(&quot;doubleValue() may only be called on values of type float or decimal.&quot;);</span>
        }
<span class="fc" id="L1574">        return value;</span>
    }

    /**
     * Decodes a string from the buffer into a String value.
     * @param valueStart the position in the buffer of the first byte in the string.
     * @param valueEnd the position in the buffer of the last byte in the string.
     * @return the value.
     */
    private String readString(int valueStart, int valueEnd) {
<span class="fc" id="L1584">        ByteBuffer utf8InputBuffer = buffer.getByteBuffer(valueStart, valueEnd);</span>
<span class="fc" id="L1585">        int numberOfBytes = valueEnd - valueStart;</span>
<span class="fc" id="L1586">        return utf8Decoder.decode(utf8InputBuffer, numberOfBytes);</span>
    }

    @Override
    public String stringValue() {
        String value;
<span class="fc bfc" id="L1592" title="All 2 branches covered.">        if (valueType == IonType.STRING) {</span>
<span class="fc bfc" id="L1593" title="All 2 branches covered.">            if (isNullValue()) {</span>
<span class="fc" id="L1594">                return null;</span>
            }
<span class="fc" id="L1596">            value = readString(valueStartPosition, valueEndPosition);</span>
<span class="fc bfc" id="L1597" title="All 2 branches covered.">        } else if (valueType == IonType.SYMBOL) {</span>
<span class="fc bfc" id="L1598" title="All 2 branches covered.">            if (isNullValue()) {</span>
<span class="fc" id="L1599">                return null;</span>
            }
<span class="fc" id="L1601">            int sid = (int) readUInt();</span>
<span class="fc" id="L1602">            value = getSymbol(sid);</span>
<span class="fc bfc" id="L1603" title="All 2 branches covered.">            if (value == null) {</span>
<span class="fc" id="L1604">                throw new UnknownSymbolException(sid);</span>
            }
<span class="fc" id="L1606">        } else {</span>
<span class="fc" id="L1607">            throw new IllegalStateException(&quot;Invalid type requested.&quot;);</span>
        }
<span class="fc" id="L1609">        return value;</span>
    }

    @Override
    public SymbolToken symbolValue() {
<span class="fc" id="L1614">        requireType(IonType.SYMBOL);</span>
<span class="fc bfc" id="L1615" title="All 2 branches covered.">        if (isNullValue()) {</span>
<span class="fc" id="L1616">            return null;</span>
        }
<span class="fc" id="L1618">        int sid = (int) readUInt();</span>
<span class="fc" id="L1619">        return getSymbolToken(sid);</span>
    }

    @Override
    public int byteSize() {
<span class="pc bpc" id="L1624" title="1 of 4 branches missed.">        if (!IonType.isLob(valueType) &amp;&amp; !isNullValue()) {</span>
<span class="fc" id="L1625">            throw new IonException(&quot;Reader must be positioned on a blob or clob.&quot;);</span>
        }
<span class="fc" id="L1627">        return valueEndPosition - valueStartPosition;</span>
    }

    @Override
    public byte[] newBytes() {
<span class="fc" id="L1632">        byte[] bytes = new byte[byteSize()];</span>
        // The correct number of bytes will be requested from the buffer, so the limit is set at the capacity to
        // avoid having to calculate a limit.
<span class="fc" id="L1635">        buffer.copyBytes(valueStartPosition, bytes, 0, bytes.length);</span>
<span class="fc" id="L1636">        return bytes;</span>
    }

    @Override
    public int getBytes(byte[] bytes, int offset, int len) {
<span class="fc" id="L1641">        int length = Math.min(len, byteSize() - lobBytesRead);</span>
        // The correct number of bytes will be requested from the buffer, so the limit is set at the capacity to
        // avoid having to calculate a limit.
<span class="fc" id="L1644">        buffer.copyBytes(valueStartPosition + lobBytesRead, bytes, offset, length);</span>
<span class="fc" id="L1645">        lobBytesRead += length;</span>
<span class="fc" id="L1646">        return length;</span>
    }

    /**
     * Reads a decimal value as a BigDecimal.
     * @return the value.
     */
    private BigDecimal readBigDecimal() {
<span class="fc" id="L1654">        int length = valueEndPosition - peekIndex;</span>
<span class="fc bfc" id="L1655" title="All 2 branches covered.">        if (length == 0) {</span>
<span class="fc" id="L1656">            return BigDecimal.ZERO;</span>
        }
<span class="fc" id="L1658">        int scale = -readVarInt();</span>
        BigDecimal value;
<span class="fc bfc" id="L1660" title="All 2 branches covered.">        if (length &lt; LONG_SIZE_IN_BYTES) {</span>
            // No need to allocate a BigInteger to hold the coefficient.
<span class="fc" id="L1662">            long coefficient = 0;</span>
<span class="fc" id="L1663">            int sign = 1;</span>
<span class="fc bfc" id="L1664" title="All 2 branches covered.">            if (peekIndex &lt; valueEndPosition) {</span>
<span class="fc" id="L1665">                int firstByte = buffer.peek(peekIndex++);</span>
<span class="fc bfc" id="L1666" title="All 2 branches covered.">                sign = (firstByte &amp; HIGHEST_BIT_BITMASK) == 0 ? 1 : -1;</span>
<span class="fc" id="L1667">                coefficient = firstByte &amp; LOWER_SEVEN_BITS_BITMASK;</span>
            }
<span class="fc bfc" id="L1669" title="All 2 branches covered.">            while (peekIndex &lt; valueEndPosition) {</span>
<span class="fc" id="L1670">                coefficient = (coefficient &lt;&lt; VALUE_BITS_PER_UINT_BYTE) | buffer.peek(peekIndex++);</span>
            }
<span class="fc" id="L1672">            value = BigDecimal.valueOf(coefficient * sign, scale);</span>
<span class="fc" id="L1673">        } else {</span>
            // The coefficient may overflow a long, so a BigInteger is required.
<span class="fc" id="L1675">            value = new BigDecimal(readIntAsBigInteger(valueEndPosition), scale);</span>
        }
<span class="fc" id="L1677">        return value;</span>
    }

    /**
     * Reads a decimal value as a Decimal.
     * @return the value.
     */
    private Decimal readDecimal() {
<span class="fc" id="L1685">        int length = valueEndPosition - peekIndex;</span>
<span class="fc bfc" id="L1686" title="All 2 branches covered.">        if (length == 0) {</span>
<span class="fc" id="L1687">            return Decimal.ZERO;</span>
        }
<span class="fc" id="L1689">        int scale = -readVarInt();</span>
        BigInteger coefficient;
<span class="fc" id="L1691">        length = valueEndPosition - peekIndex;</span>
<span class="fc bfc" id="L1692" title="All 2 branches covered.">        if (length &gt; 0) {</span>
            // NOTE: unfortunately, there is no BigInteger(int signum, byte[] bits, int offset, int length) constructor,
            // so copying to scratch space is always required.
<span class="fc" id="L1695">            byte[] bits = copyBytesToScratch(peekIndex, length);</span>
<span class="fc" id="L1696">            int signum = getAndClearSignBit(bits);</span>
            // NOTE: there is a BigInteger.valueOf(long unscaledValue, int scale) factory method that avoids allocating
            // a BigInteger for coefficients that fit in a long. See its use in readBigDecimal() above. Unfortunately,
            // it is not possible to use this for Decimal because the necessary BigDecimal constructor is
            // package-private. If a compatible BigDecimal constructor is added in a future JDK revision, a
            // corresponding factory method should be added to Decimal to enable this optimization.
<span class="fc" id="L1702">            coefficient = new BigInteger(signum, bits);</span>
<span class="pc bpc" id="L1703" title="1 of 4 branches missed.">            if (coefficient.signum() == 0 &amp;&amp; signum &lt; 0) {</span>
<span class="fc" id="L1704">                return Decimal.negativeZero(scale);</span>
            }
<span class="fc" id="L1706">        }</span>
        else {
<span class="fc" id="L1708">            coefficient = BigInteger.ZERO;</span>
        }
<span class="fc" id="L1710">        return Decimal.valueOf(coefficient, scale);</span>
    }

    @Override
    public BigDecimal bigDecimalValue() {
<span class="fc" id="L1715">        requireType(IonType.DECIMAL);</span>
<span class="fc bfc" id="L1716" title="All 2 branches covered.">        if (isNullValue()) {</span>
<span class="fc" id="L1717">            return null;</span>
        }
<span class="fc" id="L1719">        peekIndex = valueStartPosition;</span>
<span class="fc" id="L1720">        return readBigDecimal();</span>
    }

    @Override
    public Decimal decimalValue() {
<span class="fc" id="L1725">        requireType(IonType.DECIMAL);</span>
<span class="fc bfc" id="L1726" title="All 2 branches covered.">        if (isNullValue()) {</span>
<span class="fc" id="L1727">            return null;</span>
        }
<span class="fc" id="L1729">        peekIndex = valueStartPosition;</span>
<span class="fc" id="L1730">        return readDecimal();</span>
    }

    @Override
    public Timestamp timestampValue() {
<span class="fc" id="L1735">        requireType(IonType.TIMESTAMP);</span>
<span class="fc bfc" id="L1736" title="All 2 branches covered.">        if (isNullValue()) {</span>
<span class="fc" id="L1737">            return null;</span>
        }
<span class="fc" id="L1739">        peekIndex = valueStartPosition;</span>
<span class="fc" id="L1740">        int firstByte = buffer.peek(peekIndex++);</span>
<span class="fc" id="L1741">        Integer offset = null;</span>
<span class="fc bfc" id="L1742" title="All 2 branches covered.">        if (firstByte != VAR_INT_NEGATIVE_ZERO) {</span>
<span class="fc" id="L1743">            offset = readVarInt(firstByte);</span>
        }
<span class="fc" id="L1745">        int year = readVarUInt();</span>
<span class="fc" id="L1746">        int month = 0;</span>
<span class="fc" id="L1747">        int day = 0;</span>
<span class="fc" id="L1748">        int hour = 0;</span>
<span class="fc" id="L1749">        int minute = 0;</span>
<span class="fc" id="L1750">        int second = 0;</span>
<span class="fc" id="L1751">        BigDecimal fractionalSecond = null;</span>
<span class="fc" id="L1752">        Timestamp.Precision precision = Timestamp.Precision.YEAR;</span>
<span class="fc bfc" id="L1753" title="All 2 branches covered.">        if (peekIndex &lt; valueEndPosition) {</span>
<span class="fc" id="L1754">            month = readVarUInt();</span>
<span class="fc" id="L1755">            precision = Timestamp.Precision.MONTH;</span>
<span class="fc bfc" id="L1756" title="All 2 branches covered.">            if (peekIndex &lt; valueEndPosition) {</span>
<span class="fc" id="L1757">                day = readVarUInt();</span>
<span class="fc" id="L1758">                precision = Timestamp.Precision.DAY;</span>
<span class="fc bfc" id="L1759" title="All 2 branches covered.">                if (peekIndex &lt; valueEndPosition) {</span>
<span class="fc" id="L1760">                    hour = readVarUInt();</span>
<span class="fc bfc" id="L1761" title="All 2 branches covered.">                    if (peekIndex &gt;= valueEndPosition) {</span>
<span class="fc" id="L1762">                        throw new IonException(&quot;Timestamps may not specify hour without specifying minute.&quot;);</span>
                    }
<span class="fc" id="L1764">                    minute = readVarUInt();</span>
<span class="fc" id="L1765">                    precision = Timestamp.Precision.MINUTE;</span>
<span class="fc bfc" id="L1766" title="All 2 branches covered.">                    if (peekIndex &lt; valueEndPosition) {</span>
<span class="fc" id="L1767">                        second = readVarUInt();</span>
<span class="fc" id="L1768">                        precision = Timestamp.Precision.SECOND;</span>
<span class="fc bfc" id="L1769" title="All 2 branches covered.">                        if (peekIndex &lt; valueEndPosition) {</span>
<span class="fc" id="L1770">                            fractionalSecond = readBigDecimal();</span>
<span class="fc bfc" id="L1771" title="All 4 branches covered.">                            if (fractionalSecond.signum() &lt; 0 || fractionalSecond.compareTo(BigDecimal.ONE) &gt;= 0) {</span>
<span class="fc" id="L1772">                                throw new IonException(&quot;The fractional seconds value in a timestamp must be greater&quot; +</span>
                                        &quot;than or equal to zero and less than one.&quot;);
                            }
                        }
                    }
                }
            }
        }
        try {
<span class="fc" id="L1781">            return Timestamp.createFromUtcFields(</span>
                    precision,
                    year,
                    month,
                    day,
                    hour,
                    minute,
                    second,
                    fractionalSecond,
                    offset
            );
<span class="fc" id="L1792">        } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L1793">            throw new IonException(&quot;Illegal timestamp encoding. &quot;, e);</span>
        }
    }

    /**
     * Gets the annotation symbol IDs for the current value, reading them from the buffer first if necessary.
     * @return the annotation symbol IDs, or an empty list if the current value is not annotated.
     */
    private IntList getAnnotationSids() {
<span class="fc bfc" id="L1802" title="All 2 branches covered.">        if (annotationSids.isEmpty()) {</span>
<span class="fc" id="L1803">            int savedPeekIndex = peekIndex;</span>
<span class="fc" id="L1804">            peekIndex = annotationStartPosition;</span>
<span class="fc bfc" id="L1805" title="All 2 branches covered.">            while (peekIndex &lt; annotationEndPosition) {</span>
<span class="fc" id="L1806">                annotationSids.add(readVarUInt());</span>
            }
<span class="fc" id="L1808">            peekIndex = savedPeekIndex;</span>
        }
<span class="fc" id="L1810">        return annotationSids;</span>
    }

    @Override
    public String[] getTypeAnnotations() {
<span class="fc bfc" id="L1815" title="All 2 branches covered.">        if (hasAnnotations) {</span>
<span class="fc" id="L1816">            IntList annotationSids = getAnnotationSids();</span>
<span class="fc" id="L1817">            String[] annotationArray = new String[annotationSids.size()];</span>
<span class="fc bfc" id="L1818" title="All 2 branches covered.">            for (int i = 0; i &lt; annotationArray.length; i++) {</span>
<span class="fc" id="L1819">                String symbol = getSymbol(annotationSids.get(i));</span>
<span class="fc bfc" id="L1820" title="All 2 branches covered.">                if (symbol == null) {</span>
<span class="fc" id="L1821">                    throw new UnknownSymbolException(annotationSids.get(i));</span>
                }
<span class="fc" id="L1823">                annotationArray[i] = symbol;</span>
            }
<span class="fc" id="L1825">            return annotationArray;</span>
        }
<span class="fc" id="L1827">        return _Private_Utils.EMPTY_STRING_ARRAY;</span>
    }

    @Override
    public SymbolToken[] getTypeAnnotationSymbols() {
<span class="fc bfc" id="L1832" title="All 2 branches covered.">        if (hasAnnotations) {</span>
<span class="fc" id="L1833">            IntList annotationSids = getAnnotationSids();</span>
<span class="fc" id="L1834">            SymbolToken[] annotationArray = new SymbolToken[annotationSids.size()];</span>
<span class="fc bfc" id="L1835" title="All 2 branches covered.">            for (int i = 0; i &lt; annotationArray.length; i++) {</span>
<span class="fc" id="L1836">                annotationArray[i] = getSymbolToken(annotationSids.get(i));</span>
            }
<span class="fc" id="L1838">            return annotationArray;</span>
        }
<span class="fc" id="L1840">        return SymbolToken.EMPTY_ARRAY;</span>
    }

<span class="fc" id="L1843">    private static final Iterator&lt;String&gt; EMPTY_ITERATOR = new Iterator&lt;String&gt;() {</span>

        @Override
        public boolean hasNext() {
<span class="fc" id="L1847">            return false;</span>
        }

        @Override
        public String next() {
<span class="nc" id="L1852">            return null;</span>
        }

        @Override
        public void remove() {
<span class="nc" id="L1857">            throw new UnsupportedOperationException(&quot;Cannot remove from an empty iterator.&quot;);</span>
        }
    };

    @Override
    public Iterator&lt;String&gt; iterateTypeAnnotations() {
<span class="fc bfc" id="L1863" title="All 2 branches covered.">        if (hasAnnotations) {</span>
<span class="fc bfc" id="L1864" title="All 2 branches covered.">            if (isAnnotationIteratorReuseEnabled) {</span>
<span class="fc" id="L1865">                annotationIterator.ready();</span>
<span class="fc" id="L1866">                return annotationIterator;</span>
            } else {
<span class="fc" id="L1868">                return new SingleUseAnnotationIterator();</span>
            }
        }
<span class="fc" id="L1871">        return EMPTY_ITERATOR;</span>
    }

    @Override
    public int getFieldId() {
<span class="fc" id="L1876">        return fieldNameSid;</span>
    }

    @Override
    public String getFieldName() {
<span class="fc bfc" id="L1881" title="All 2 branches covered.">        if (fieldNameSid &lt; 0) {</span>
<span class="fc" id="L1882">            return null;</span>
        }
<span class="fc" id="L1884">        String fieldName = getSymbol(fieldNameSid);</span>
<span class="fc bfc" id="L1885" title="All 2 branches covered.">        if (fieldName == null) {</span>
<span class="fc" id="L1886">            throw new UnknownSymbolException(fieldNameSid);</span>
        }
<span class="fc" id="L1888">        return fieldName;</span>
    }

    @Override
    public SymbolToken getFieldNameSymbol() {
<span class="fc bfc" id="L1893" title="All 2 branches covered.">        if (fieldNameSid &lt; 0) {</span>
<span class="fc" id="L1894">            return null;</span>
        }
<span class="fc" id="L1896">        return getSymbolToken(fieldNameSid);</span>
    }

    @Override
    public boolean isNullValue() {
<span class="fc bfc" id="L1901" title="All 4 branches covered.">        return valueTypeID != null &amp;&amp; valueTypeID.isNull;</span>
    }

    @Override
    public boolean isInStruct() {
<span class="fc bfc" id="L1906" title="All 4 branches covered.">        return !containerStack.isEmpty() &amp;&amp; containerStack.peek().type == IonType.STRUCT;</span>
    }

    @Override
    public boolean booleanValue() {
<span class="fc" id="L1911">        requireType(IonType.BOOL);</span>
<span class="fc bfc" id="L1912" title="All 2 branches covered.">        return valueTypeID.lowerNibble == 1;</span>
    }

    @Override
    public &lt;T&gt; T asFacet(Class&lt;T&gt; facetType) {
<span class="fc" id="L1917">        return null;</span>
    }

    @Override
    public void requireCompleteValue() {
        // NOTE: If we want to replace the other binary IonReader implementation with this one, the following
        // validation could be performed in next() if incremental mode is not enabled. That would allow this
        // implementation to behave in the same way as the other implementation when an incomplete value is
        // encountered.
<span class="fc bfc" id="L1926" title="All 2 branches covered.">        if (lookahead.isSkippingCurrentValue()) {</span>
<span class="fc" id="L1927">            throw new IonException(&quot;Unexpected EOF.&quot;);</span>
        }
<span class="fc bfc" id="L1929" title="All 4 branches covered.">        if (lookahead.available() &gt; 0 &amp;&amp; lookahead.moreDataRequired()) {</span>
<span class="fc bfc" id="L1930" title="All 2 branches covered.">            if (lookahead.getIvmIndex() &lt; 0</span>
<span class="fc bfc" id="L1931" title="All 2 branches covered.">                || lookahead.available() != _Private_IonConstants.BINARY_VERSION_MARKER_SIZE) {</span>
<span class="fc" id="L1932">                throw new IonException(&quot;Unexpected EOF.&quot;);</span>
            }
        }
<span class="fc" id="L1935">    }</span>

    @Override
    public void close() throws IOException {
<span class="fc" id="L1939">        requireCompleteValue();</span>
<span class="fc" id="L1940">        inputStream.close();</span>
<span class="fc" id="L1941">        utf8Decoder.close();</span>
<span class="fc" id="L1942">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>